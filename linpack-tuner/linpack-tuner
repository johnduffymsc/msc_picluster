#!/usr/bin/python3

import datetime
import math
import os
import subprocess


# Hard coded program parameters. TODO: Change to user parameters.

NODES = 8
CORES_PER_NODE = 4
GIGABYTES_PER_NODE = 4
MEMORY_PERCENT = [80, 100]
NB = [96, 256]


# Template HPL.dat file contents.

HPL_DAT = """
HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
0            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
{:<5}        Ns
1            # of NBs
{:<5}        NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
{:<5}        Ps
{:<5}        Qs
16.0         threshold
3            # of panel fact
0 1 2        PFACTs (0=left, 1=Crout, 2=Right)
2            # of recursive stopping criterium
2 4          NBMINs (>= 1)
1            # of panels in recursion
2            NDIVs
3            # of recursive panel fact.
0 1 2        RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
0            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
0            DEPTHs (>=0)
2            SWAP (0=bin-exch,1=long,2=mix)
64           swapping threshold
0            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (> 0)
"""


def calculate_n(nodes, gigabytes_per_node, memory_percentage, nb):
    """
    This function returns the parameter N.
    """
    return int(
        (
            (
                memory_percentage
                / 100
                * math.sqrt(nodes * gigabytes_per_node * 1024 ** 3 / 8)
            )
            // nb
        )
        * nb
    )


def calculate_pq(nodes, cores_per_node):
    """
    This function returns a list of P and Q tuples.
    """
    pq = []
    cores = nodes * cores_per_node
    for i in range(1, int(math.sqrt(cores)) + 1):
        if cores % i == 0 and i < cores // i:  # Ensure P < Q.
            pq.append((i, cores // i))
    return pq


# This main program loop iterates over the MEMORY_PERCENT and NB user supplied
# lists and calculates the associated n, and p and q parameters. Together with
# the current value of nb, these parameters are then used to populate a new
# HPL.dat file. The Linpack executable is then run, capturing the output in a
# new HPL.out file.
#
# Any Linpack execution errors results in this program exiting.
#
# TODO: Fix!
# At end of each iteration of the inner loop the test results are extracted
# from the HPL.out file and appended to a HPL.out.combined."memory_percent"
# file. This file contains the 18 test results from each iteration. These results
# are then sorted and the best result appended to a
# HPL.results.plot."memory"

for memory_percent in MEMORY_PERCENT:

    for nb in NB:

        n = calculate_n(NODES, GIGABYTES_PER_NODE, memory_percent, nb)

        pq = calculate_pq(NODES, CORES_PER_NODE)

        for i in range(len(pq)):

            # Delete any old HPL.dat and HPL.out files (possibly from a crash).
            try:
                os.remove("HPL.dat")
                os.remove("HPL.out")
            except:
                # Ignore any exceptions, the files may not exist.
                pass

            # Create a new HPL.dat file, populating it with n, nb, p and q.
            try:
                with open("HPL.dat", "w") as f:
                    f.write(HPL_DAT.format(n, nb, pq[i][0], pq[i][1]))
            except IOError as e:
                print("I/O error: {0}".format(e))
                exit()

            # Run Linpack.
            try:
                pass
                # subprocess.run(["mpirun", "-host", "nodes", "-np", "4", "xhpl"])
            except:
                pass

            # Archive the current HPL.dat and HPL.out files.
            try:
                suffix = "{}_{}_{}_{}_{}".format(NODES, n, nb, p, q)
                dtg = datetime.datetime.now().strftime("%FT%T")
                # os.rename("HPL.dat", "HPL.dat.{}.{}".format(suffix, dtg))
                # os.rename("HPL.out", "HPL.out.{}.{}".format(suffix, dtg))
            except:
                # The above archiving should work if we have got to this point.
                pass

